#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  StopBumper,     sensorTouch)
#pragma config(Sensor, I2C_1,  RightBaseIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  LeftElbowIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  WristIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  RightElbowIEM,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  LeftBaseIEM,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  SholderIEM,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           LeftBase,      tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_5, 1000)
#pragma config(Motor,  port3,           Shoulder,      tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_6, 1000)
#pragma config(Motor,  port4,           Wrist,         tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port5,           RightBase,     tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           Claw,          tmotorVex269, openLoop)
#pragma config(Motor,  port7,           LeftElbow,     tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port8,           RightElbow,    tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <values.h>


typedef struct point
{
	float x;
	float y;
}point;

point* goal =  point;

float q2 = SensorValue[SholderIEM];
float q1 = SensorValue[LeftElbowIEM];

task controle
{
	while(1==1)
	{
		if(vexRT[Btn5U])
		{
			motor[Claw]=40;
		}
		else if(vexRT[Btn5D])
		{
			motor[Claw]=-40;
		}
		if((vexRT[Btn5D]&&vexRT[Btn5U])||!(vexRT[Btn5D]||vexRT[Btn5U])){motor[Claw]=0;}

		if(vexRT[Btn7L])
		{
			motor[Claw]=40;
		}
		else if(vexRT[Btn7D])
		{
			motor[Claw]=-40;
		}
		if((vexRT[Btn7D]&&vexRT[Btn7L])||!(vexRT[Btn7L]||vexRT[Btn7D])){motor[Claw]=0;}

		if(vexRT[Btn6U])
		{
			goal->y+=1;
		}
		else if(vexRT[Btn6D])
		{
			goal->y-=1;
		}

		motor[LeftBase]=vexRT[Ch3]-vexRT[Ch4];
		motor[RightBase]=vexRT[Ch3]+vexRT[Ch4];

		motor[LeftBase]=vexRT[Ch1];
		motor[RightBase]=-vexRT[Ch1];

		goal->x+=vexRT[Ch1]/20;
	}
}
point *joint = point;
bool cal = false;
task calulate
{
	while(true)
	{
		if(cal)
		{
			float y2=goal->y*goal->y;
			float x2=goal->x*goal->x;
			float U2=UpperArmLength*UpperArmLength;
			float L2=LowerArmLength*LowerArmLength;
			float a=1+(y2)/(x2);
			float b=goal->y*(-1*y2-1*L2+U2)-goal->y;
			float c=-1*L2+(y2*(y2+2*(L2-1*U2+x2))+L2*(L2+2*(-1*U2+x2))-1*U2*(-1*U2+2*x2)+x2*x2)/(4*x2);
			joint->y=(-b-sqrt(b*b-4*a*c))/(2*a);
			a=1+x2/y2;
			b=goal->x*(-1*x2-1*L2+U2)/y2-goal->x;
			c=-1*L2+(x2*(x2+2*(L2-1*U2+y2))+L2*(L2+2*(-1*U2+y2))-1*U2*(-1*U2+2*y2)+y2*y2)/(4*y2);
			if(goal->x>0)
			{
				joint->x=(-b-sqrt(b*b-4*a*c))/(2*a);
				writeDebugStream("dgtdgts%d\n",joint->x);

			}
			else
			{
				joint->x=(-b+sqrt(b*b-4*a*c))/(2*a);
			}
			q2 = joint->y/joint->x;
			q1 = (goal->y-joint->y)/(goal->x-joint->x);

			cal=false;
		}
	}
}

task motorFunctions
{
	while(1)
	{
		if(q2!=SensorValue[SholderIEM]/SholderGearDown)
		{
			if(q2>SensorValue[SholderIEM]/SholderGearDown)
			{
				motor[Shoulder]=120;
			}
			else
			{
				motor[Shoulder]=-120;
			}
		}
		else
		{
			motor[Shoulder]=0;
		}
		if(q1!=SensorValue(SholderIEM)/ElbowGearDown)
		{
			if(q1>SensorValue[SholderIEM]/ElbowGearDown)
			{
				motor[RightElbow]=50;
				motor[LeftElbow]=50;
			}
			else
			{
				motor[RightElbow]=-50;
				motor[LeftElbow]=-50;
			}
		}
		else
		{
				motor[RightElbow]=0;
				motor[LeftElbow]=0;
		}
	}
}


task main
{
	goal->x=UpperArmLength;
	goal->y=LowerArmLength;
	/*zero out sensors*/

	wait1Msec(2000);
	StartTask(controle);
	StartTask(calulate);
	while(vexRT[Btn7D]==0&&SensorValue(StopBumper)==0)
	{}
	StopAllTasks();
}
