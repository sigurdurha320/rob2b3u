#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  StopBumper,     sensorTouch)
#pragma config(Sensor, I2C_1,  RightBaseIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  LeftBaseIEM,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  RightElbowIEM,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  LeftElbowIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  WristIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  SholderIEM,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           LeftBase,      tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_5, 1000)
#pragma config(Motor,  port3,           Shoulder,      tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_6, 1000)
#pragma config(Motor,  port4,           Wrist,         tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port5,           RightBase,     tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           Claw,          tmotorVex269, openLoop)
#pragma config(Motor,  port7,           LeftElbow,     tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port8,           RightElbow,    tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typeDef point
{
	float x;
	float y;
}point;

point goal = new point;
goal.x=UpperArmLength;
goal.y=LowerArmLength;

task controle
{
	while(1==1)
	{
		if(vexRT[Btn5U])
		{
			motor[Shoulder]=125;
		}
		else{motor[Shoulder]=0;}
		if(vexRT[Btn5D])
		{
			motor[Shoulder]=-125;
		}
		else{motor[Shoulder]=0;}
		motor[Wrist]=vexRT[ch1];
		motor[LeftElbow]=vexRT[ch2];
		motor[RightElbow]=vexRT[ch2];
		motor[LeftBase]=vexRT[ch3]-vexRT[ch4];
		motor[RightBase]=vexRT[ch3]+vexRT[ch4];
	}
}

task motorize
{
	point last = new point();
	point joint = new point();
	if(last.x!=goal.x || last.y!=goal.y)
	{
		float y2=goal.y*goal.y;
		float x2=goal.x*goal.x;
		float U2=UpperArmLength*UpperArmLength;
		float L2=LowerArmLength*LowerArmLength;
		float a=1+(y2)/(x2)
		float b=goal.y*(-1*y2-1*L2+U2)-goal.y;
		float c=-1*L2+(y2*(y2+2*(L2-1*U2+x2))+L2*(L2+2*(-1*U2+x2))-1*U2*(-1*U2+2*x2)+x2*x2)/(4*x2);
		joint.y=(-b-sqrt(b*b-4*a*c))/(2*a);
		a=1+x2/y2;
		b=goal.x*(-1*x2-1*L2+U2)/y2-goal.x;
		c=-1*L2+(x2*(x2+2*(L2-1*U2+y2))+L2*(L2+2*(-1*U2+y2))-1*U2*(-1*U2+2*y2)+y2*y2)/(4*y2);
		if(goal.x>0)
		{
			joint.x=(-b-sqrt(b*b-4*a*c))/(2*a);
		}
		else
		{
			joint.x=(-b+sqrt(b*b-4*a*c))/(2*a);
		}
		float q2 = joint.y/joint.x;
		float q1 = (goal.y-joint.y)/(goal.x-joint.x);
	}
}


task main
{
	wait1Msec(2000);
	StartTask(controle);
	StartTask(motorize);
	while(vexRT[Btn7D]==0&&SensorValue(StopBumper)==0)
	{}
	StopAllTasks();
}